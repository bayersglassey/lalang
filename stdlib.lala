
# "abc" "xyz" @zip @list -> [["a", "x"], ["b", "y"], ["c", "z"]]
# "abc" "xy" @zip @list -> [["a", "x"], ["b", "y"]]
# "ab" "xyz" @zip @list -> [["a", "x"], ["b", "y"]]
"zip" @class =zip
[
    =self
    @iter self =.it2
    @iter self =.it1
    self
] $__init__ zip .add_getter
{ } $__iter__ zip .add_getter
[
    =self
    self .it1 @next {
        =val1
        self .it2 @next {
            =val2
            val1 val2 @pair true
        } { false } @ifelse
    } { false } @ifelse
] $__next__ zip .add_getter


# "abc" @enumerate @list -> [["a", 0], ["b", 1], ["c", 2]]
"enumerate" @class =enumerate
[
    =self
    @iter self =.it
    0 self =.i
    self
] $__init__ enumerate .add_getter
{ } $__iter__ enumerate .add_getter
[
    =self
    self .it @next {
        self .i @pair =next
        self .i 1 + self =.i
        next true
    } { false } @ifelse
] $__next__ enumerate .add_getter


# ( 0 3 @range ) { 10 * } @map @list -> [0, 10, 20]
"map" @class =map
[
    =self
    self =.func
    @iter self =.it
    self
] $__init__ map .add_getter
{ } $__iter__ map .add_getter
[
    =self
    self .it @next {
        self .func @
        true
    } { false } @ifelse
] $__next__ map .add_getter


# ( 0 6 @range ) { 2 % 0 == } @filter @list -> [0, 2, 4]
"filter" @class =filter
[
    =self
    self =.func
    @iter self =.it
    self
] $__init__ filter .add_getter
{ } $__iter__ filter .add_getter
[
    =self

    # Recursive implementation looks so simple!.. but eats stack:
    # self .it @next {
    #     =x
    #     x self .func @ { x true } { self @next } @ifelse
    # } { false } @ifelse

    # Implementation with a while-loop:
    {
        self .it @next {
            # we got a potential next value
            =x
            x self .func @ {
                # the value passed the filter
                x true # return next value
                false # break out of the while-loop
            } {
                # the value did not pass the filter
                true # continue the while-loop
            } @ifelse
        } {
            # end of iteration
            false # return end-of-iteration
            false # break out of the while-loop
        } @ifelse
    } { } @while
] $__next__ filter .add_getter


# "zabcba" @sorted -> ["a", "a", "b", "b", "c", "z"]
{ @list @dup .sort } =$sorted


# "abc" @reversed -> ["c", "b", "a"]
{ @list @dup .reverse } =$reversed


# @conds: implements if..elif..elif..else
{
    @locals [ =locals
        # get arguments
        =n
        =else
        n 2 * list .build =conds

        # check the conds
        0 =i false =matched
        { ( matched ! ) ( i n < ) & } {
            i 2 * conds .get .copy =cond
            locals cond =.locals
            @cond =matched
            matched {
                i 2 * 1 + conds .get .copy =then
                locals then =.locals
                @then
            } @if
            i 1 + =i
        } @while

        # if no conds matched, run the else-branch
        matched ! {
            else .copy =else
            locals else =.locals
            @else
        } @if
    ] @
} =$conds


# list .new "a" , "b" , "c" , @join -> "abc"
[
    @iter =it
    "" { + } it @for
] =$join


# E.g. if COND1 then THEN1 elif COND2 then THEN2 else ELSE end
# ...becomes: { COND1 } { THEN1 } { COND2 } { THEN2 } { ELSE } 2 @cond
[
    =x
    x @typeof =T
    { T int == } {
        x 0 == { "0" } {
            "0123456789" =DIGITS
            x 0 < =neg
            list .new
            neg { x ~ =x "-" , } @if
            { x 0 > } { x 10 % DIGITS .get , x 10 / =x } @while
            @join
        } @ifelse
    } { T bool == } {
        x { "true" } { "false" } @ifelse
    } { T nulltype == } {
        "null"
    } { T str == } {
        list .new "\"" , x , "\"" , @join
    } { T list == } {
        list .new "[" ,
        true =first
        { first { false =first } { @swap ", " , @swap } @ifelse @repr , } x @for
        "]" , @join
    } { T dict == } {
        list .new "{" ,
        true =first
        { first { false =first } { @swap ", " , @swap } @ifelse .unpair =v , ": " , v @repr , } x .items @for
        "}" , @join
    } { T type == } {
        list .new "<type '" , x .name , "'>" , @join
    } { list .new "<'" , T .name , "' object>" , @join }
    7 @conds
    # TODO: add cases for iterator, func
    # TODO: how can we make this work for classes?..
    # And also for types defined in C?..
    # We need something like a @getters function, which unlike .__getters__
    # (which can fail), always returns a dict?..
] =$repr


# E.g. "mymodule" @include looks for "mymodule.lala" or "mymodule.so"
[
    =name
    ( "." "/" name .replace ".lala" + ) @readfile =code
    code null != {
        code @eval
    } {
        # NOTE: currently only checks for .so files in current directory...
        ( "./" name + ".so" + ) ( name "_init" + ) @dlsym
    } @ifelse
] =$include
