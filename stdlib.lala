
# "abc" "xyz" @zip @list -> [["a", "x"], ["b", "y"], ["c", "z"]]
# "abc" "xy" @zip @list -> [["a", "x"], ["b", "y"]]
# "ab" "xyz" @zip @list -> [["a", "x"], ["b", "y"]]
"zip" @class =zip
[
    =self
    @iter self =.it2
    @iter self =.it1
    self
] $__init__ zip .add_getter
{ } $__iter__ zip .add_getter
[
    =self
    self .it1 @next {
        =val1
        self .it2 @next {
            =val2
            val1 val2 @pair true
        } { false } @ifelse
    } { false } @ifelse
] $__next__ zip .add_getter

# "abc" @enumerate @list -> [["a", 0], ["b", 1], ["c", 2]]
"enumerate" @class =enumerate
[
    =self
    @iter self =.it
    0 self =.i
    self
] $__init__ enumerate .add_getter
{ } $__iter__ enumerate .add_getter
[
    =self
    self .it @next {
        self .i @pair =next
        self .i 1 + self =.i
        next true
    } { false } @ifelse
] $__next__ enumerate .add_getter


# ( 0 3 @range ) { 10 * } @map @list -> [0, 10, 20]
"map" @class =map
[
    =self
    self =.func
    @iter self =.it
    self
] $__init__ map .add_getter
{ } $__iter__ map .add_getter
[
    =self
    self .it @next {
        self .func @
        true
    } { false } @ifelse
] $__next__ map .add_getter


# ( 0 6 @range ) { 2 % 0 == } @filter @list -> [0, 2, 4]
"filter" @class =filter
[
    =self
    self =.func
    @iter self =.it
    self
] $__init__ filter .add_getter
{ } $__iter__ filter .add_getter
[
    =self

    # Recursive implementation looks so simple!.. but eats stack:
    # self .it @next {
    #     =x
    #     x self .func @ { x true } { self @next } @ifelse
    # } { false } @ifelse

    # Implementation with a while-loop:
    {
        self .it @next {
            # we got a potential next value
            =x
            x self .func @ {
                # the value passed the filter
                x true # return next value
                false # break out of the while-loop
            } {
                # the value did not pass the filter
                true # continue the while-loop
            } @ifelse
        } {
            # end of iteration
            false # return end-of-iteration
            false # break out of the while-loop
        } @ifelse
    } { } @while
] $__next__ filter .add_getter

# "zabcba" @sorted -> ["a", "a", "b", "b", "c", "z"]
{ @list @dup .sort } =$sorted

# "abc" @reversed -> ["c", "b", "a"]
{ @list @dup .reverse } =$reversed

# @conds: implements if..elif..elif..else
{
    @locals [ =locals
        # get arguments
        =n
        =else
        n 2 * list .build =conds

        # check the conds
        0 =i false =matched
        { ( matched ! ) ( i n < ) & } {
            i 2 * conds .get .copy =cond
            locals cond =.locals
            @cond =matched
            matched {
                i 2 * 1 + conds .get .copy =then
                locals then =.locals
                @then
            } @if
            i 1 + =i
        } @while

        # if no conds matched, run the else-branch
        matched ! {
            else .copy =else
            locals else =.locals
            @else
        } @if
    ] @
} =$conds
